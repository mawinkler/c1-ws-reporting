#!/usr/bin/python3
"""
---
module: antimalware_report.py

short_description: Queries Cloud One Workload Security or Deep Security for
                   scheduled scan and antimalware events within a given
                   timeframe. Creates an Excel file with the report.

description:
    - "TODO"

configuration:
    Create a config.yml based on the .sample

usage:
    ./antimalware_report.py

options:
    none

author:
    - Markus Winkler (markus_winkler@trendmicro.com)
"""
import ssl
import json
import sys
import logging
from datetime import datetime
import urllib3
import pandas as pd
import requests
import yaml
from requests import Session
from zeep.client import Client
from zeep.transports import Transport

# Globals
# ssl._create_default_https_context = ssl._create_unverified_context
# urllib3.disable_warnings()

_LOGGER = logging.getLogger(__name__)
logging.basicConfig(stream=sys.stdout, level=logging.INFO,
                    format='%(asctime)s %(levelname)s (%(threadName)s) [%(funcName)s] %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S')
logging.getLogger("requests").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)

# 794	Scheduled Malware Scan Failure Resolved
# 795	Scheduled Malware Scan Failure
# 796	Scheduled Malware Scan Task has been Missed
# 1527	Scheduled Malware Scan Cancellation In Progress
# 1528	Scheduled Malware Scan Cancellation Completed
# 1531	Scheduled Malware Scan Paused
# 1532	Scheduled Malware Scan Resumed
# 1547	Scheduled Malware Scan Task has been cancelled
SCHEDULED_MALWARE_SCAN_STARTED = 1523
SCHEDULED_MALWARE_SCAN_COMPLETED = 1524

SCAN_TYPE = "ALL" #"SCHEDULED"
SCAN_TYPE_ALL = "ALL"



def get_paged_computers(api_key, host, verify):
    """Retrieve all computers"""

    paged_computers = []
    id_value, total_num = 0, 0
    max_items = 2000

    header = {"api-version": "v1", "api-secret-key": api_key}
    session_url = "https://" + host + "/api/computers/search"
    query = {"expand": "antiMalware"}


    try:
        while True:
            payload = {
                "maxItems": max_items,
                "searchCriteria": [
                    {
                        "idValue": id_value,
                        "idTest": "greater-than",
                    }
                ],
                "sortByObjectID": "true",
            }

            response = requests.post(
                session_url, headers=header, params=query, json=payload, verify=verify
            )
            response.raise_for_status()
            computers = json.loads(response.content)

            num_found = len(computers["computers"])
            if num_found == 0:
                break

            for computer in computers["computers"]:
                paged_computers.append(computer)

            id_value = computers["computers"][-1]["ID"]

            if num_found == 0:
                break

            total_num = total_num + num_found

        return paged_computers

    except requests.exceptions.Timeout as err:
        _LOGGER.error(response.text)
        raise SystemExit(err)
    except requests.exceptions.HTTPError as err:
        _LOGGER.error(response.text)
        raise SystemExit(err)
    except requests.exceptions.RequestException as err:
        # catastrophic error. bail.
        _LOGGER.error(response.text)
        raise SystemExit(err)


def get_indexed(data, index):
    """Index a list"""

    indexed_data = {}
    for element in data:
        indexed_data[element[index]] = element

    return indexed_data


def get_computers_groups(api_key, host, verify=True):
    """Retrieve computer groups"""

    session_url = "https://" + host + "/api/computergroups"
    headers = {"api-secret-key": api_key, "api-version": "v1"}

    try:
        response = requests.request("GET", session_url, headers=headers, verify=verify)
        response.raise_for_status()
    except requests.exceptions.Timeout as err:
        _LOGGER.error(response.text)
        raise SystemExit(err)
    except requests.exceptions.HTTPError as err:
        _LOGGER.error(response.text)
        raise SystemExit(err)
    except requests.exceptions.RequestException as err:
        # catastrophic error. bail.
        _LOGGER.error(response.text)
        raise SystemExit(err)

    computer_groups = response.json()
    indexed_computer_groups = {}
    for element in computer_groups["computerGroups"]:
        indexed_computer_groups[element["ID"]] = element

    return indexed_computer_groups


def get_policies(api_key, host, verify=True):
    """Retrive policies"""

    session_url = "https://" + host + "/api/policies"
    headers = {"api-secret-key": api_key, "api-version": "v1"}

    try:
        response = requests.request("GET", session_url, headers=headers, verify=verify)
        response.raise_for_status()
    except requests.exceptions.Timeout as err:
        _LOGGER.error(response.text)
        raise SystemExit(err)
    except requests.exceptions.HTTPError as err:
        _LOGGER.error(response.text)
        raise SystemExit(err)
    except requests.exceptions.RequestException as err:
        # catastrophic error. bail.
        _LOGGER.error(response.text)
        raise SystemExit(err)

    policies = response.json()
    return policies["policies"]


def add_computer_info(api_key, host, computers, verify):
    """Add additional information to the computers list"""

    computers_groups = get_computers_groups(api_key, host, verify)
    policies = get_policies(api_key, host, verify)
    indexed_policies = get_indexed(data=policies, index="ID")
    computer_info_list = []

    for computer in computers:
        computer_info = {
            "id": computer["ID"],
            "name": computer["hostName"],
            "os": computer["platform"],
            "am_mode": computer["antiMalware"]["state"],
        }
        if computer["groupID"] != 0:
            computer_info["group"] = computers_groups[computer["groupID"]]["name"]
        if "policyID" in computer:
            computer_info["policy"] = indexed_policies[computer["policyID"]]["name"]
        computer_info_list.append(
            computer_info,
        )

    return computer_info_list


def soap_auth(client, tenant, username, password):
    """Authenticate to the web services"""

    if not tenant:
        return client.service.authenticate(
            username=username, password=password
        )
    return client.service.authenticateTenant(
        tenantName=tenant, username=username, password=password
    )

def logout(client, sID):
    """Terminate session"""

    client.service.endSession(sID)
    return True


def create_event_id_filter(factory, id, operator):
    """Create an event id filter"""

    EnumOperator = factory.EnumOperator(operator)
    IDFilterTransport = factory.IDFilterTransport(id=id, operator=EnumOperator)
    return IDFilterTransport


def create_host_filter(factory, groupID, hostID, securityProfileID, enumType):
    """Create a host filter"""

    EnumHostFilter = factory.EnumHostFilterType(enumType)
    HostFilterTransport = factory.HostFilterTransport(
        hostGroupID=groupID,
        hostID=hostID,
        securityProfileID=securityProfileID,
        type=EnumHostFilter,
    )
    return HostFilterTransport


def create_file_filter(factory, TimeRangeFrom, TimeRangeTo, TimeSpecific, type):
    """Create a file filter"""

    Timetype = factory.EnumTimeFilterType(type)
    TimeFilterTransport = factory.TimeFilterTransport(
        rangeFrom=TimeRangeFrom,
        rangeTo=TimeRangeTo,
        specificTime=TimeSpecific,
        type=Timetype,
    )
    return TimeFilterTransport


def get_am_events(
    client,
    factory,
    timespan_from,
    timespan_to,
    tenant,
    username,
    password,
    indexed_computers,
    scan_type=SCAN_TYPE_ALL,
):
    """Retrieve anti malware events"""
    
    sID = soap_auth(client, tenant, username, password)
    epochStart = datetime.strptime(timespan_from + " 00:00:00", "%m.%d.%Y %H:%M:%S")
    epochEnd = datetime.strptime(timespan_to + " 23:59:59", "%m.%d.%Y %H:%M:%S")
    events = []
    id_value, num_requests = 0, 0

    while True:
        try:
            amEvents = client.service.antiMalwareEventRetrieve(
                timeFilter=create_file_filter(
                    factory, epochStart, epochEnd, None, "CUSTOM_RANGE"
                ),
                hostFilter=create_host_filter(factory, None, None, None, "ALL_HOSTS"),
                eventIdFilter=create_event_id_filter(factory, id_value, "GREATER_THAN"),
                sID=sID,
            )

        except Exception as err:
            _LOGGER.error(err)
            raise SystemExit(err)

        if amEvents["antiMalwareEvents"] is not None:
            for event in amEvents["antiMalwareEvents"]["item"]:
                eventID = event["scanType"]
                if scan_type == SCAN_TYPE_ALL or scan_type == eventID:
                    format_event = {
                        "antiMalwareConfigID": event["antiMalwareConfigID"],
                        "antiMalwareEventID": event["antiMalwareEventID"],
                        "endTime": event["endTime"],
                        "errorCode": event["errorCode"],
                        "hostID": event["hostID"],
                        "infectedFilePath": event["infectedFilePath"],
                        "infectionSource": event["infectionSource"],
                        "logDate": event["logDate"].strftime("%m.%d.%Y %H:%M:%S"),
                        "malwareName": event["malwareName"],
                        "malwareType": event["malwareType"],
                        "protocol": event["protocol"],
                        "quarantineRecordID": event["quarantineRecordID"],
                        "scanResultAction1": event["scanResultAction1"],
                        "dscanResultAction2ata": event["scanResultAction2"],
                        "scanType": event["scanType"],
                        "spywareItems": event["spywareItems"],
                        "startTime": event["startTime"],
                        "tags": event["tags"],
                        "scanAction1": event["scanAction1"],
                        "scanAction2": event["scanAction2"],
                        "summaryScanResult": event["summaryScanResult"],
                    }

                    if "hostID" in event:
                        if event["hostID"] in indexed_computers:
                            if "group" in indexed_computers[event["hostID"]]:
                                format_event["computerGroup"] = indexed_computers[
                                    event["hostID"]
                                ]["group"]
                    if "computerGroup" not in format_event:
                        format_event["computerGroup"] = "None"

                    events.append(
                        format_event,
                    )

            id_value = amEvents["antiMalwareEvents"]["item"][-1]["antiMalwareEventID"]

            num_requests += 1
            if num_requests == 100:
                logout(client, sID)
                num_requests = 0
                sID = soap_auth(client, tenant, username, password)
        else:
            logout(client, sID)
            break

    return events


def get_sys_events(
    client,
    factory,
    timespan_from,
    timespan_to,
    tenant,
    username,
    password,
    indexed_computers,
    event_id=0,
):
    """Retrieve system events"""

    sID = soap_auth(client, tenant, username, password)
    epochStart = datetime.strptime(timespan_from + " 00:00:00", "%m.%d.%Y %H:%M:%S")
    epochEnd = datetime.strptime(timespan_to + " 23:59:59", "%m.%d.%Y %H:%M:%S")

    events = []
    id_value, num_requests = 0, 0

    while True:
        try:
            sysEvents = client.service.systemEventRetrieve(
                timeFilter=create_file_filter(
                    factory, epochStart, epochEnd, None, "CUSTOM_RANGE"
                ),
                hostFilter=create_host_filter(factory, None, None, None, "ALL_HOSTS"),
                eventIdFilter=create_event_id_filter(factory, id_value, "GREATER_THAN"),
                includeNonHostEvents=False,
                sID=sID,
            )
        except Exception as err:
            _LOGGER.error(err)
            raise SystemExit(err)

        if sysEvents["systemEvents"] is not None:
            for event in sysEvents["systemEvents"]["item"]:
                eventID = event["eventID"]
                if event_id == 0 or event_id == eventID:
                    format_event = {
                        "actionPerformedBy": event["actionPerformedBy"],
                        "description": event["description"],
                        "event": event["event"],
                        "eventID": event["eventID"],
                        "eventOrigin": event["eventOrigin"],
                        "managerHostname": event["managerHostname"],
                        "systemEventID": event["systemEventID"],
                        "tags": event["tags"],
                        "target": event["target"],
                        "targetID": event["targetID"],
                        "targetType": event["targetType"],
                        "time": event["time"],
                        "type": event["type"],
                    }

                    if "targetID" in event:
                        if event["targetID"] in indexed_computers:
                            if "group" in indexed_computers[event["targetID"]]:
                                format_event["computerGroup"] = indexed_computers[
                                    event["targetID"]
                                ]["group"]
                    if "computerGroup" not in format_event:
                        format_event["computerGroup"] = "None"

                    events.append(
                        format_event,
                    )

            id_value = sysEvents["systemEvents"]["item"][-1]["systemEventID"]

            num_requests += 1
            if num_requests == 100:
                logout(client, sID)
                num_requests = 0
                sID = soap_auth(client, tenant, username, password)
        else:
            logout(client, sID)
            break

    return events


def getSystemEventID(element):
    """Returns the systemEventID of a given event"""

    return element["systemEventID"]


def main():
    """Main function"""

    # Read configuration
    with open("config.yml", "r") as ymlfile:
        cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)

    host = cfg["deepsecurity"]["server"]
    tenant = cfg["deepsecurity"].get("tenant", None)
    # username = cfg["deepsecurity"]["username"]
    # password = cfg["deepsecurity"]["password"]
    c1_api_key = cfg["deepsecurity"]["c1_api_key"]
    ws_api_key = cfg["deepsecurity"]["ws_api_key"]
    # tenant = cfg["deepsecurity"].get("tenant", None)
    timespan_from = cfg["deepsecurity"]["timespan_from"]
    timespan_to = cfg["deepsecurity"]["timespan_to"]
    tls_verify = bool(cfg["deepsecurity"].get("tls_verify", True))

    if tls_verify == False:
        _LOGGER.info("Disabling TLS verify")
        ssl._create_default_https_context = ssl._create_unverified_context
        urllib3.disable_warnings()
    
    _LOGGER.info("Retrieving computers...")
    computers = get_paged_computers(ws_api_key, host, verify=tls_verify)

    computers_info = add_computer_info(ws_api_key, host, computers, verify=tls_verify)
    indexed_computers = get_indexed(data=computers_info, index="id")

    session = Session()
    session.verify = tls_verify
    transport = Transport(session=session, timeout=1800)
    url = "https://{0}/webservice/Manager?WSDL".format(host)
    client = Client(url, transport=transport)
    factory = client.type_factory("ns0")

    ###
    # Scheduled Scans
    # Not fully handled job started the day before or finished after
    # midnight
    ###
    _LOGGER.info("Retrieving system events 'Scheduled Malware Scan Started'")
    sys_events = get_sys_events(
        client,
        factory,
        timespan_from,
        timespan_to,
        tenant,
        "Authorization:ApiKey",
        c1_api_key,
        indexed_computers,
        event_id=SCHEDULED_MALWARE_SCAN_STARTED,
    )
    _LOGGER.info("Retrieving system events 'Scheduled Malware Scan Completed'")
    sys_events = sys_events + get_sys_events(
        client,
        factory,
        timespan_from,
        timespan_to,
        tenant,
        "Authorization:ApiKey",
        c1_api_key,
        indexed_computers,
        event_id=SCHEDULED_MALWARE_SCAN_COMPLETED,
    )
    _LOGGER.info("Sort mixed events by 'systemEventID'")
    sys_events.sort(key=getSystemEventID)

    targetIDs = set()
    scanCount = 0
    for scan in sys_events:
        if scan["eventID"] == SCHEDULED_MALWARE_SCAN_STARTED:
            if scan["targetID"] in targetIDs:
                _LOGGER.info("Scan already active for %s", scan["targetID"])
            else:
                scanCount += 1
                targetIDs.add(scan["targetID"])
        if scan["eventID"] == SCHEDULED_MALWARE_SCAN_COMPLETED:
            if not scan["targetID"] in targetIDs:
                _LOGGER.info("No active scan found for %s", scan["targetID"])
            else:
                targetIDs.remove(scan["targetID"])

    if len(targetIDs) == 0:
        _LOGGER.info("All scans finished")
    else:
        _LOGGER.info("%d scans running", len(targetIDs))

    ###
    # Anti Malware Findings (Within scheduled scans only)
    ###
    _LOGGER.info("Retrieving anti malware events for %s scans", SCAN_TYPE)
    am_events = get_am_events(
        client,
        factory,
        timespan_from,
        timespan_to,
        tenant,
        "Authorization:ApiKey",
        c1_api_key,
        indexed_computers,
        scan_type=SCAN_TYPE,
    )

    ###
    # Creating Result Sets
    ###
    _LOGGER.info("Calculating result sets")
    # Create result set: {malware, {computers}}
    am_result = {}
    for am_event in am_events:
        if am_event["malwareName"] in am_result:
            ll = am_result.get(am_event["malwareName"])
        else:
            ll = set()
        ll.add(indexed_computers[am_event["hostID"]]["name"])
        am_result[am_event["malwareName"]] = ll

    # Create result set: {malware, str(computers)}
    am_result_list = {}
    for result in am_result:
        am_result_list[result] = ", ".join(
            "{}".format(val) for (val) in am_result[result]
        )

    # Populate statistics
    am_result_stats = {}
    am_result_stats["computers"] = len(computers)
    am_result_stats["scan_count"] = scanCount
    am_result_stats["scans_running"] = len(targetIDs)
    am_result_stats["no_malwares_variants"] = len(am_result)

    # Create result set: {malware, #computers}
    malware_computer_count = {}
    for am_event in am_events:
        if am_event["malwareName"] in malware_computer_count:
            ll = malware_computer_count.get(am_event["malwareName"])
        else:
            ll = set()
        ll.add(indexed_computers[am_event["hostID"]]["name"])
        malware_computer_count[am_event["malwareName"]] = ll
    for malware in malware_computer_count:
        malware_computer_count[malware] = len(malware_computer_count[malware])

    ###
    # Create Excel Report
    ###
    _LOGGER.info("Create Excel report")
    # Create a Pandas dataframe from the data.
    df = pd.DataFrame([malware_computer_count], index=["Variant Distribution"])

    # Create a Pandas Excel writer using XlsxWriter as the engine.
    excel_file = "pie.xlsx"
    sheet_name = "Variant Distribution"

    writer = pd.ExcelWriter(excel_file, engine="xlsxwriter")
    workbook = writer.book
    worksheet = workbook.add_worksheet(sheet_name)
    writer.sheets[sheet_name] = worksheet

    # Format cells.
    format_malware = workbook.add_format()  # ({'num_format': '0%'})
    format_malware.set_align("left")
    worksheet.set_column("A:A", 24, format_malware)

    format_columns = workbook.add_format()
    format_columns.set_align("right")
    worksheet.set_column("B:B", 77, format_columns)

    df.to_excel(writer, sheet_name=sheet_name, startrow=0, startcol=26)

    # Create a chart object.
    chart = workbook.add_chart({"type": "pie"})
    chart.set_size({"width": 720, "height": 576})
    chart.set_style(10)
    chart.set_title({"name": "Malware Variants"})

    # Configure the chart from the dataframe data.
    chart.add_series(
        {
            "categories": "='{}'!AB1:A{}1".format(
                sheet_name, chr(65 + am_result_stats["no_malwares_variants"])
            ),
            "values": "='{}'!AB2:A{}2".format(
                sheet_name, chr(65 + am_result_stats["no_malwares_variants"])
            ),
        }
    )

    # Insert the chart into the worksheet.
    worksheet.insert_chart("A1", chart)

    # Insert statistics table
    ds = pd.Series(data=am_result_stats)
    ds.to_excel(writer, sheet_name=sheet_name, startrow=30, startcol=0, header=False)

    # Insert malware variant discovered on computer table
    ds = pd.Series(data=am_result_list, dtype = 'object')
    ds.to_excel(writer, sheet_name=sheet_name, startrow=35, startcol=0, header=False)

    # Close the Pandas Excel writer and output the Excel file.
    writer.save()


if __name__ == "__main__":
    main()
